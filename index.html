<script>
let leftLane = null;
let rightLane = null;
const laneHistory = { left: [], right: [], max: 5 }; // smoothing over last 5 frames

function detectLanes(frame){
  let src = cv.matFromImageData(frame);
  let gray = new cv.Mat();
  let edges = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(gray, gray, new cv.Size(5,5), 0);
  cv.Canny(gray, edges, 50, 150);

  // Define ROI polygon (bottom half of the image)
  let mask = new cv.Mat.zeros(edges.rows, edges.cols, edges.type());
  let pts = cv.matFromArray(4,1,cv.CV_32SC2,[
    0, edges.rows,
    edges.cols, edges.rows,
    edges.cols, edges.rows*0.6,
    0, edges.rows*0.6
  ]);
  cv.fillPoly(mask, [pts], [255,255,255,255]);
  cv.bitwise_and(edges, mask, edges);

  // Hough lines
  let lines = new cv.Mat();
  cv.HoughLinesP(edges, lines, 1, Math.PI/180, 50, 50, 50);

  // Separate left and right lines
  let leftLines = [], rightLines = [];
  for(let i=0; i<lines.rows; i++){
    let [x1,y1,x2,y2] = lines.data32S.slice(i*4,i*4+4);
    let slope = (y2 - y1) / (x2 - x1 + 0.0001);
    if(Math.abs(slope) < 0.3) continue; // ignore almost horizontal
    if(slope < 0) leftLines.push([x1,y1,x2,y2]);
    else rightLines.push([x1,y1,x2,y2]);
  }

  function averageLine(lines){
    if(lines.length === 0) return null;
    let x1=0,y1=0,x2=0,y2=0;
    lines.forEach(l=>{
      x1 += l[0]; y1 += l[1]; x2 += l[2]; y2 += l[3];
    });
    return [x1/lines.length, y1/lines.length, x2/lines.length, y2/lines.length];
  }

  leftLane = averageLine(leftLines) || leftLane;
  rightLane = averageLine(rightLines) || rightLane;

  // Smoothing
  if(leftLane) {
    laneHistory.left.push(leftLane);
    if(laneHistory.left.length > laneHistory.max) laneHistory.left.shift();
    leftLane = laneHistory.left.reduce((acc,l)=>{
      return acc.map((v,i)=>v+l[i]);
    }, [0,0,0,0]).map(v=>v/laneHistory.left.length);
  }
  if(rightLane) {
    laneHistory.right.push(rightLane);
    if(laneHistory.right.length > laneHistory.max) laneHistory.right.shift();
    rightLane = laneHistory.right.reduce((acc,l)=>{
      return acc.map((v,i)=>v+l[i]);
    }, [0,0,0,0]).map(v=>v/laneHistory.right.length);
  }

  // Draw lanes
  ctx.strokeStyle='lime';
  ctx.lineWidth=5;
  [leftLane,rightLane].forEach(l=>{
    if(!l) return;
    ctx.beginPath();
    ctx.moveTo(l[0]*canvas.width/video.videoWidth, l[1]*canvas.height/video.videoHeight);
    ctx.lineTo(l[2]*canvas.width/video.videoWidth, l[2]*canvas.height/video.videoHeight);
    ctx.stroke();
  });

  src.delete(); gray.delete(); edges.delete(); mask.delete(); lines.delete(); pts.delete();
}
</script>
