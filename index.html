<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Road Assistant</title>
<style>
body, html { margin:0; padding:0; overflow:hidden; background:black; font-family:sans-serif; }
#canvas { position:absolute; top:0; left:0; width:100%; height:100%; }
.ui-overlay {
  position:absolute; top:10px; left:10px; z-index:2;
  background:rgba(255,255,255,0.8); padding:10px; border-radius:10px;
  box-shadow:0 2px 10px rgba(0,0,0,0.3);
  color:black;
}
button { margin-top:5px; padding:5px 10px; border:none; border-radius:5px; background:#333; color:white; cursor:pointer; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div class="ui-overlay">
  <h3>3D Road Assistant</h3>
  <p>Detects road lanes and cars; self-learning mode enabled.</p>
  <button id="downloadData">Download Training Data</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.9.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
<script async src="https://docs.opencv.org/4.8.0/opencv.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Camera setup
const video = document.createElement('video');
video.autoplay = true;
video.muted = true;
video.playsInline = true;
navigator.mediaDevices.getUserMedia({ video: { facingMode:"environment" } })
  .then(stream => video.srcObject = stream);

// Alarm
const beep = new Howl({ src:['https://actions.google.com/sounds/v1/alarms/beep_short.ogg'] });

// Load object detection
let model;
cocoSsd.load().then(m => { model = m; detectFrame(); });

// Self-training data
const trainingData = [];
document.getElementById('downloadData').onclick = () => {
  const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(trainingData));
  const dl = document.createElement('a');
  dl.setAttribute('href', dataStr);
  dl.setAttribute('download', 'training_data.json');
  dl.click();
};

// Lane detection (clean)
function detectLanes(frame){
  let src = cv.matFromImageData(frame);
  let gray = new cv.Mat();
  let edges = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(gray, gray, new cv.Size(5,5), 0);
  cv.Canny(gray, edges, 50, 150);

  // Lower half of the frame
  let mask = cv.Mat.zeros(edges.rows, edges.cols, edges.type());
  let roiPts = cv.matFromArray(4,1,cv.CV_32SC2, [
    0, edges.rows,
    edges.cols, edges.rows,
    edges.cols, edges.rows/2,
    0, edges.rows/2
  ]);
  let pts = new cv.MatVector();
  pts.push_back(roiPts);
  cv.fillPoly(mask, pts, new cv.Scalar(255));
  let maskedEdges = new cv.Mat();
  cv.bitwise_and(edges, mask, maskedEdges);

  // Hough Lines
  let lines = new cv.Mat();
  cv.HoughLinesP(maskedEdges, lines, 1, Math.PI/180, 50, 50, 100);

  let lineCount = 0;
  ctx.strokeStyle = 'lime';
  ctx.lineWidth = 5;

  for(let i=0; i<lines.rows && lineCount<6; i++){
    let [x1,y1,x2,y2] = lines.data32S.slice(i*4, i*4+4);
    let slope = (y2-y1)/(x2-x1+0.0001);
    if(Math.abs(slope) < 0.3) continue; // ignore horizontal
    ctx.beginPath();
    ctx.moveTo(x1 * canvas.width/video.videoWidth, y1 * canvas.height/video.videoHeight);
    ctx.lineTo(x2 * canvas.width/video.videoWidth, y2 * canvas.height/video.videoHeight);
    ctx.stroke();
    lineCount++;
  }

  src.delete(); gray.delete(); edges.delete(); mask.delete(); maskedEdges.delete(); lines.delete(); pts.delete(); roiPts.delete();
}

// Draw objects (cars)
function drawObjects(predictions){
  predictions.forEach(pred=>{
    if(pred.class==='car' || pred.class==='truck'){
      let x = pred.bbox[0]/video.videoWidth*canvas.width;
      let y = pred.bbox[1]/video.videoHeight*canvas.height;
      let width = pred.bbox[2]/video.videoWidth*canvas.width;
      let height = pred.bbox[3]/video.videoHeight*canvas.height;
      ctx.strokeStyle='red';
      ctx.lineWidth=3;
      ctx.strokeRect(x, y, width, height);

      // Proximity alarm
      if(pred.bbox[3] > 150) beep.play();
    }
  });
}

// Save frame + predictions
function saveTraining(frame, predictions){
  trainingData.push({
    timestamp: Date.now(),
    frame: frame.data.slice(0, 10000), // only first 10k pixels to reduce size
    predictions
  });
}

// Main loop
function detectFrame(){
  if(!model || !cv || !cv.Mat) return requestAnimationFrame(detectFrame);

  ctx.drawImage(video,0,0,canvas.width,canvas.height);
  const frame = ctx.getImageData(0,0,canvas.width,canvas.height);

  detectLanes(frame);

  model.detect(video).then(predictions=>{
    drawObjects(predictions);
    saveTraining(frame, predictions);
    requestAnimationFrame(detectFrame);
  });
}
</script>
</body>
</html>
